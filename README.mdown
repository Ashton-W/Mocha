# Mocha
### Objective-C / JavaScript Bridge


Mocha is a runtime that bridges JavaScript to Objective-C. It is built on top of JavaScriptCore, the component of WebKit responsible for parsing and evaluating JavaScript code, and BridgeSupport, which enables libraries to expose the definition of their C structures and functions for use at run-time (as opposed to compile-time).


## Usage

Instances of the `Mocha` class are representations of a runtime. A runtime can be used either through shared instance (returned from `-sharedRuntime`) or by creating an instance by calling `-init` or `-initWithGlobalContext:`.


## Values and Boxed Objects

When arguments are passed between the Objective-C and JavaScript sides of the bridge they may be implicitly converted to an appropriate type counterpart or boxed within an opaque proxy object. The following type conventions are in effect when moving between each side of the bridge:

### Objective-C to JavaScript
- `nil` is converted to `null`
- `NSNull` is converted to `null`
- `MOUndefined` is converted to `undefined`
- `char*` is converted to `String`
- **Objective-C methods** are converted to `MOMethod`, and are callable
- **Blocks** are boxed within an opaque `Object` type, and are callable
- **C functions** are boxed within an opaque `Object` type, and are callable
- **C structs** are boxed within an opaque `Object` type, allowing direct access to members in a dictionary-like manner.
- **C numeric primitives** (`int`, `long`, `short`, `char`, `float`, `double`, etc.) are converted to `Number`
- `bool` and `_Bool` are converted to `Boolean`
- **Pointers** are boxed within an opaque `Object` type
- **All other Objective-C objects** are boxed within an opaque `Object` type. This type can be converted to `String` or `Number` from within JavaScript. `NSString` instances will convert to `String` appropriately. `NSNumber` instances will convert to `Number` appropriately. All other conversions will use the `-description` method of the `NSObject` subclass.

Note: `BOOL`, unlike `bool`, is converted to `Number`, as `BOOL` is typedef'd as an `unsigned char` in Objective-C.

### JavaScript to Objective-C
- `String` is converted to `NSString` or `char*`, depending on context
- `Number` is converted to `NSNumber` or a **C numeric primitive**, depending on context
- `Boolean` is converted to `NSNumber`, `bool` or `_Bool`, depending on context
- `Array` is converted to `NSArray`
- `Object` is converted to `NSDictionary`
- `null` is converted to `nil` (when bare) or `NSNull` (when placed in a container)
- `undefined` is converted to `MOUndefined`
- **All boxed types** are unboxed


## Functions and Methods

### Arguments

Arguments to C functions and Objective-C methods are automatically converted when crossing the bridge, as discussed above.

Variable-argument functions work as expected. Objective-C functions that require a terminating sentinel (through the `NS_REQUIRES_NIL_TERMINATION` compiler attribute) **do not** require a trailing `null`.

#### Example:
<pre>
// ObjC
NSArray *array = [NSArray arrayWithObjects:first, second, third, nil];

// JavaScript
var array = NSArray.arrayWithObjects_(first, second, third);
</pre>


### Objective-C Selectors

Objective-C methods are exposed as properties of the object's opaque JavaScript proxy. When a method is invoked, it is automatically converted to the appropriate selector on the Objective-C side of the bridge, and all arguments are converted to the appropriate types.

Method name conversion follow a similar pattern to PyObjC. The following steps are taken when converting a selector name to the JavaScript property name:
- All colons are converted to underscores.
- Each component of the selector is concatenated into a single string with no separation.

As such, a selector such as `executeOperation:withObject:error:` is converted to the function name `executeOperation_withObject_error_()`. The reverse is done to convert the property name back into an Objective-C selector.

### Exposing Objective-C methods

By default, all methods and properties of an Objective-C object crossing the bridge are available to be invoked. If you wish to specifically exclude methods from invocation on the JavaScript side of the bridge, use the `+isSelectorExcludedFromMochaScript:` method. Objects implementing this method can return `YES` for any selector that should not be invoked from the bridge.

#### Example:
<pre>
// ObjC
@implementation MyClass
â€¦

+ (BOOL)isSelectorExcludedFromMochaScript:(SEL)selector {
    if (selector == @selector(someMethod)) {
        return YES;
    }
    return [super isSelectorExcludedFromMochaScript:selector];
}

@end

// JavaScript
var result = myObject.someMethod();
>>> "MOJavaScriptException: ReferenceError: Can't find variable: someMethod"
</pre>


## Frameworks

Frameworks that expose BridgeSupport information (as all public OS X frameworks do) can be imported through the use of the `loadFramework` built-in function.

#### Example:
<pre>
AVAsset.assetWithURL_(url);
>>> "MOJavaScriptException: ReferenceError: Can't find variable: AVAsset"

loadFramework('AVFoundation');

AVAsset.assetWithURL_(url);
>>> "&lt;AVURLAsset: 0x7fe803ce8340&gt;"
</pre>

On OS X, the following frameworks are imported automatically: Foundation, CoreGraphics.


## Globals

### Global Objects

Arbitrary Objective-C objects and methods can be exposed as global objects to the runtime without needing to declare BridgeSupport information. The `Mocha` class is a fully Key-Value Coding compliant container for just this purpose. Calling `-valueForKey:` and `-setValue:forKey:` exposes an object to the runtime, assuming it can be boxed as an appropriate JavaScript type (see above).

#### Example:
<pre>
// ObjC
Mocha *runtime = [Mocha sharedRuntime];
MyClass *object = [[[MyClass alloc] init];
[runtime setValue:object forKey:@"MyObject"];

// JavaScript
var result = MyObject.someMethod();
</pre>

### Global Functions

To expose arbitrary global functions to the runtime, use the `MOMethod` class. Instances of the class keep reference to a target object and Objective-C selector, which can be invoked dynamically by the runtime whenever the method is called on the JavaScript side of the bridge. Like all other objects, methods can be exposed using the `-valueForKey:` and `-setValue:forKey:` methods of the `Mocha` class.

#### Example:
<pre>
// ObjC
Mocha *runtime = [Mocha sharedRuntime];
MOMethod *method = [MOMethod methodWithTarget:myObject selector:@selector(someMethod)];
[runtime setValue:method forKey:@"someMethod"];

// JavaScript
var result = someMethod();
</pre>


## Object Subscripting

Objects that support indexed-access (acting as array-types) or keyed-access (acting as dictionary-types) can support the JavaScript subscripting syntax for accessing values.

### Indexed Subscripting

Implementing `-objectForIndexedSubscript:` allows an object to use the `object[idx]` syntax for read-only access to values. For read-write access, you should also implement the `-setObject:forIndexedSubscript:` method. Both of these methods are declared within an informal protocol defined in MochaRuntime.h.

`NSArray` and `NSMutableArray`, and `NSOrderedSet` and `NSMutableOrderedSet` automatically adopt this syntax (through a swizzled category on 10.7 and before, or through automatically supporting the Objective-C indexed subscripting syntax on 10.8+).

### Keyed Subscripting

Implementing `-objectForKeyedSubscript:` allows an object to use the `object['key']` syntax for read-only access to values. For read-write access, you should also implement the `-setObject:forKeyedSubscript:` method. Both of these methods are declared within an informal protocol defined in MochaRuntime.h.

`NSDictionary` and `NSMutableDictionary` automatically adopt this syntax (through a swizzled category on 10.7 and before, or through automatically supporting the Objective-C keyed subscripting syntax on 10.8+).


## Introspecting the Objective-C Runtime

Mocha adds several facilities for introspecting the Objective-C runtime. The built-in object `objc` can be used to query various attributes about the Objective-C runtime. Use the `-classes` and `-classWithName:` methods to get information about classes registered with the runtime, or `-protocols` and `-protocolWithName:` to get information about protocols registered with the runtime.

An NSObject category is also added by the Mocha runtime to add additional introspection abilities to class objects. Use the `+ancestors` method to get a list of a class's superclass chain. Use the `+classMethods`, `+instanceMethods`, `+properties`, and `+protocols` methods to query information about a class's class methods, instance methods, properties, and protocols, respectively. Note that these methods only return methods, properties and protocols defined by the class itself. As a convenience, Mocha also provides the following methods to query for the entire superclass chain: `+classMethodsWithAncestors`, `+instanceMethodsWithAncestors`, `+propertiesWithAncestors`, and `+protocolsWithAncestors`.


## Exceptions

Exceptions in Objective-C code can be automatically caught by JavaScript exception handlers. The value of the `err` argument within the `try {} catch (err) {}` block will be a boxed `NSException` instance.

JavaScript exceptions that are uncaught will be converted to `NSException` objects with a name of `MOJavaScriptException`. They can be caught in an Objective-C `@try {} @catch (NSException *e) {}` block just like any other exception.

Mocha exceptions that do not originate from within the JavaScript environment carry the name `MORuntimeException`, and generally indicate a more serious failure caused by an issue within the runtime.


## moc: The Mocha Interpreter

`moc` is a simple command-line interpreter for debugging and testing with Mocha. It is similar to `jsc`, provided as part of JavaScriptCore.

`moc` has the following set of built-in functions:
- `exit()` â€“ Exits the interpreter
- `gc()` â€“ Instructs the JavaScript garbage collector to perform a collection
- `checkSyntax(string)` â€“ Validates the syntax of `string`, returning a `Boolean`


## iOS Support

iOS support is currently non-functional. The plan is to change this soon. :)


## Code Usage

Mocha utilizes some code and ideas from both PyObjC (http://pyobjc.sourceforge.net/, MIT license) and JSCocoa (http://inexdo.com/JSCocoa, MIT license).
Implementation files are marked appropriately when code it utilized in complete or near-complete duplicate from these awesome projects.


## License

Copyright 2012 Logan Collins

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.